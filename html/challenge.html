<!DOCTYPE html>
<!--
Based on David Leadbeater's work
See https://github.com/dgl/haphash
-->
<head>
    <meta name="viewport" content="width=device-width" />
    <title>You know the drill.</title>
    <style>
        @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap");

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%%;
        }

        body {
            background-image: url("data:image/svg+xml,%%3Csvg xmlns='http://www.w3.org/2000/svg' width='1920' height='1080' fill='none'%%3E%%3Cscript xmlns=''/%%3E%%3Cg opacity='.2' clip-path='url(%%23E)'%%3E%%3Cpath d='M1466.4 1795.2c950.37 0 1720.8-627.52 1720.8-1401.6S2416.77-1008 1466.4-1008-254.4-380.482-254.4 393.6s770.428 1401.6 1720.8 1401.6z' fill='url(%%23A)'/%%3E%%3Cpath d='M394.2 1815.6c746.58 0 1351.8-493.2 1351.8-1101.6S1140.78-387.6 394.2-387.6-957.6 105.603-957.6 714-352.38 1815.6 394.2 1815.6z' fill='url(%%23B)'/%%3E%%3Cpath d='M1548.6 1885.2c631.92 0 1144.2-417.45 1144.2-932.4S2180.52 20.4 1548.6 20.4 404.4 437.85 404.4 952.8s512.276 932.4 1144.2 932.4z' fill='url(%%23C)'/%%3E%%3Cpath d='M265.8 1215.6c690.246 0 1249.8-455.595 1249.8-1017.6S956.046-819.6 265.8-819.6-984-364.005-984 198-424.445 1215.6 265.8 1215.6z' fill='url(%%23D)'/%%3E%%3C/g%%3E%%3Cdefs%%3E%%3CradialGradient id='A' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(1466.4 393.6) rotate(90) scale(1401.6 1720.8)'%%3E%%3Cstop stop-color='%%23107c10'/%%3E%%3Cstop offset='1' stop-color='%%23c4c4c4' stop-opacity='0'/%%3E%%3C/radialGradient%%3E%%3CradialGradient id='B' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(394.2 714) rotate(90) scale(1101.6 1351.8)'%%3E%%3Cstop stop-color='%%230078d4'/%%3E%%3Cstop offset='1' stop-color='%%23c4c4c4' stop-opacity='0'/%%3E%%3C/radialGradient%%3E%%3CradialGradient id='C' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(1548.6 952.8) rotate(90) scale(932.4 1144.2)'%%3E%%3Cstop stop-color='%%23ffb900' stop-opacity='.75'/%%3E%%3Cstop offset='1' stop-color='%%23c4c4c4' stop-opacity='0'/%%3E%%3C/radialGradient%%3E%%3CradialGradient id='D' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(265.8 198) rotate(90) scale(1017.6 1249.8)'%%3E%%3Cstop stop-color='%%23d83b01' stop-opacity='.75'/%%3E%%3Cstop offset='1' stop-color='%%23c4c4c4' stop-opacity='0'/%%3E%%3C/radialGradient%%3E%%3CclipPath id='E'%%3E%%3Cpath fill='%%23fff' d='M0 0h1920v1080H0z'/%%3E%%3C/clipPath%%3E%%3C/defs%%3E%%3Cscript xmlns=''/%%3E%%3C/svg%%3E");
            font-family: "JetBrains Mono", monospace;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            background-position: center;
            background-size: cover;
            background-repeat: no-repeat;
        }

        main {
            text-align: center;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-width: 36rem;
            width: 100%%;
            height: calc(100%% - 2rem);
        }

        main section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-grow: 1;
            justify-content: center;
        }

        main h1 {
            color: oklch(0.985 0.002 247.839);
            font-size: 6rem;
            font-weight: bold;
            margin: 0;
        }

        main h2 {
            color: oklch(0.928 0.006 264.531);
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0;
        }

        main p {
            color: oklch(0.707 0.022 261.325);
            font-size: 1.125rem;
            margin: 0;
        }

        iframe {
            display: none;
        }

        @keyframes rotate {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .rotate {
            animation: rotate 1s linear infinite;
        }
    </style>
</head>

<body>
    <main>
        <section>
            <h1 id="progress-icon" class="rotate">🌀</h1>
            <h2 id="progress-text">Checking whether you're a scraper...</h2>
        </section>
        <p>JavaScript is required to pass the challenge.</p>
    </main>
    <form method="post" target="post" action="/_challenge" name="challenge">
        <!-- This is filled by HAProxy -->
        <input type="hidden" name="ip" value="%[src]" />
        <input type="hidden" name="timestamp" value="%[date]" />
        <input type="hidden" name="difficulty" value="4" />
        <input type="hidden" name="tries" value="" />
    </form>
    <iframe srcdoc="" src="about:blank" name="post" role="presentation"></iframe>
    <script>
        "use strict";

        const progressIcon = document.getElementById("progress-icon");
        const progressText = document.getElementById("progress-text");

        /**
         * Solves the cryptographic challenge.
         * @param {number} difficulty - The difficulty level of the challenge.
         * @param {string} ip - The IP address of the user.
         * @param {string} timestamp - The timestamp of the challenge.
         * @return {Promise<number>} - The number of tries taken to solve the challenge.
         */
        async function challenge(difficulty, ip, timestamp) {
            let encoder = new TextEncoder();
            let tries = 0;
            
            for (; tries < 10_000_000; tries++) {
                let hash = await crypto.subtle.digest(
                    "SHA-256",
                    encoder.encode([ip, location.hostname, timestamp, tries].join(";"))
                );
                let hashByteArray = new Uint8Array(hash);

                let i = 0;
                while (i < difficulty / 2) {
                    if (hashByteArray[i] > 0x0f) break;
                    if (i * 2 + 1 >= difficulty) return tries;
                    if (hashByteArray[i++] > 0) break;
                    if (i * 2 >= difficulty) return tries;
                }
            }
        }

        /**
         * Checks if the browser supports WebCrypto.
         * @throws {Error} - If WebCrypto is not supported or if the page is not served over HTTPS.
         */
        async function checkCompatibility() {
            if (!("subtle" in window.crypto)) {
                if (location.protocol !== "https:") {
                    throw new Error("No WebCrypto support. This must be served over a HTTPS connection.");
                } else {
                    throw new Error("No WebCrypto support in your browser. This is required to pass the challenge.");
                }
            }
        }

        async function startChallenge(form) {
            try {
                await checkCompatibility();
            } catch (error) {
                setMessage("❌", error.message);
                return;
            }

            let backoff = 0;
            let tryOnce = (_) => {
                if (backoff > 8) {
                    setMessage("❌", "Failed to submit after several tries. Try reloading.");
                    return;
                }
                setTimeout(
                    async (_) => submitAnswer(form),
                    1000 * (Math.pow(2, backoff++) - 1)
                );
            };

            form.addEventListener("error", tryOnce);
            let iframe = document.querySelector("iframe");
            iframe.addEventListener("load", (_) =>
                location.hash.length ? location.reload() : location.replace(location)
            );
            tryOnce();
        }

        /**
         * Sets the message and icon for the progress bar.
         * @param {string} icon - The icon to display.
         * @param {string} message - The message to display.
         * @param {boolean} rotate - Whether to rotate the icon.
         */
        function setMessage(icon, message, rotate = false) {
            progressIcon.innerText = icon;
            progressText.innerText = message;
            progressIcon.classList.toggle("rotate", rotate);
        }

        async function submitAnswer(form) {
            let start = new Date();
            ;
            let tries = await challenge(form.difficulty.value, form.ip.value, form.timestamp.value);

            if (tries === undefined) {
                setMessage("🤯", "Unable to calculate challenge. Try reloading or a different browser.");
                return;
            }
            form.tries.value = tries;

            setMessage("✅", `Took ${(new Date() - start)}ms.`);
            form.submit();
        }

        window.addEventListener("load", _ => startChallenge(document.forms.challenge));
    </script>
</body>
